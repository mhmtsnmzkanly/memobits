// Memobits mega demo: most language features in one place

struct User {
    name: String,
    age: Int,
    active: Bool
}

enum Action {
    Login(User),
    Logout(String),
    UpdateAge(Int),
    Noop
}

enum MaybeInt {
    Nothing,
    Just(Int)
}

fn make_user(name: String, age: Int) -> User {
    return User { name: name, age: age, active: true };
}

fn age_group(age: Int) -> String {
    let g = if age < 13 { "kid" } else { if age < 20 { "teen" } else { "adult" } };
    return g;
}

// demonstrates if/match as expressions
fn describe_user(u: User) -> String {
    let group = age_group(u.age);
    let status = if u.active { "active" } else { "inactive" };
    let n = u.name;
    let a = u.age;
    `User {n} is {a} ({group}) and {status}`
}

fn safe_parse_int(s: String) -> Result<Int, String> {
    if s == "42" { return Ok(42); } else { return Err("not a number"); }
}

fn main_logic() -> Result<String, String> {
    let raw = native::input();
    let name = if raw == "" { "Guest" } else { raw };
    let age_text = native::input();
    let age_result = safe_parse_int(age_text);

    let user = match age_result {
        Ok(age) => make_user(name, age),
        Err(_) => make_user("Guest", 0)
    };

    let desc = describe_user(user);
    Ok(desc)
}

// ===== program start =====

// let / var, strings, template
let greeting = "Hello" + " " + "Memobits";
native::print(greeting);

// list, array, index
let nums = [1, 2, 3, 4, 5];
let arr: List<Int> = [10, 20, 30];
let third = arr[2];

// map literal + index read/write
var scores = {"alice" => 3};
scores["bob"] = 5;
let bob_score = scores["bob"];

// lambda (single param) and fn call
fn add(a: Int, b: Int) -> Int {
    return a + b;
}
let inc = x => x + 1;
let sum = add(10, 20);
let next = inc(sum);

// loop / break / continue
var i = 0;
var total = 0;
loop {
    if i >= 5 { break; }
    if i == 2 { i = i + 1; continue; }
    total = total + nums[i];
    i = i + 1;
}

// Option / Result literals (printed)
let opt = Some(7);
let res = Ok(1);

// match as expression (enum patterns)
let maybe = MaybeInt::Just(7);
let doubled = match maybe {
    MaybeInt::Nothing => 0,
    MaybeInt::Just(x) => x * 2
};

// match as expression (literal patterns)
let parity = match 3 {
    0 => "even",
    _ => "odd"
};

// custom enum value (printed)
let action = Action::Login(make_user("Ada", 17));
native::print(action);

// match as statement (literal patterns)
match 2 {
    1 => native::print("one"),
    2 => native::print("two"),
    _ => native::print("other")
};

// short-circuit boolean
let safe = false && (1 / 0 == 0);
let ok = true || (1 / 0 == 0);

native::print(`third {third}`);
native::print(`bob {bob_score}`);
native::print(`sum {sum}, next {next}`);
native::print(`loop total {total}`);
native::print(opt);
native::print(res);
native::print(`doubled {doubled}`);
native::print(parity);

// main_logic with Result
let out = main_logic();
native::print(out);
